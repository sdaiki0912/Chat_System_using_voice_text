# Overview
Current chat applications are typically limited to either text-to-text or voice-to-voice (calls). This creates a communication barrier when one person wants to speak aloud, while the other needs to use text due to their situation (e.g., being on a train). To solve this problem, I propose a new communication tool that seamlessly integrates text-to-voice, voice-to-text, and standard text messaging.
The core algorithm was drafted with the assistance of Google Gemini. Special thanks to Google.

# Communication process(Overview)
Basic idea is following 4things.<br>
 - Voice to Text(New communication): Voice -> voice recognition(Ex. Open AI whisper) -Network-> text <br>
 - Text to Voice(New communication): Text -Network-> Voice generation -> voice <br>
 - Text to Text(General communication): Text -Network-> Text<br>
 - Voice to Voice(General communication)(Not scope）: Voice -Network-> Voice<br>

This tool accommodates users in different environments. For instance, someone in a quiet office can speak, while a person on a crowded train can communicate via text. It also lowers the barrier for users who might be hesitant to initiate a direct phone call, allowing them to start with voice input and potentially transition to a full voice conversation later. This flexibility enables seamless communication across diverse scenarios.

# Algorithm
This section was generated by Google Gemini.
## Text-to-Text (T2T) 
This is the core process for sending and receiving typed messages between users. It relies on the browser's BroadcastChannel API for real-time, serverless communication between tabs.<br>

1. Message Input & Submission:<br>
- A user types a message into the ```<input id="message-input">.```　 <br>
- When the user presses "Enter" or clicks the send button, the ```<form>```'s ```submit``` event is triggered, which calls the ```sendMessage()``` function.　<br>

2. Sending Process (sendMessage function):<br>
- A ```messagePayload``` object is created, containing the message text, the sender's ID (```currentUserId```), and a ```timestamp```.<br>
- **Instant Local Display**: The ```addMessage()``` function is immediately called to display the message on the sender's own screen. This provides instant feedback.<br>
- **History Update**: The message is added to the ```chatHistory``` array and saved to the browser's ```localStorage``` using ```saveHistory()```.<br>
- **Broadcasting**: The ```channel.postMessage()``` method is called. It sends the ```messagePayload``` with the type ```new_message``` to all other browser tabs connected to the same ```BroadcastChannel``` named ```'chat_app_sync'```.<br>

3. Receiving Process (```channel.onmessage``` handler):<br>
- The other user's browser tab receives the ```new_message``` event.
- The ```onmessage``` handler first checks if the ```senderId``` in the payload is different from its own ```currentUserId``` to ensure it doesn't process its own echoed messages.
- If the message is from the other user, it calls ```addMessage()``` to display the message on the screen and updates its local chat history.

## Voice-to-Text (V2T)
This process uses the browser's built-in Web Speech API (SpeechRecognition) to convert a user's speech into text. No external libraries are needed.<br>

1. Activation:<br>
- The user clicks the microphone button, which calls the ```toggleVoiceRecognition()``` function.<br>
- This function starts the SpeechRecognition service by calling ```recognition.start()```.<br>
- It also broadcasts a ```voice_input_start``` event via the ```BroadcastChannel``` to notify the other user that voice input has begun.<br>

2. Speech Processing (Handled by the Browser):<br>
- The browser listens for audio from the user's microphone.<br>
- It sends this audio to a server (e.g., Google's or Apple's servers, depending on the browser) for processing.<br>
- The server transcribes the audio into text and sends it back to the browser.<br>

3. Receiving the Transcript (```recognition.onresult``` event):<br>
- Once the browser receives the transcribed text, it fires the ```onresult``` event.<br>
- Your ```recognition.onresult``` event handler extracts the final transcript from the event data.<br>
- It then places this text into the ```<input id="message-input">```.<br>
- Finally, it calls ```sendMessage('voice')``` to send the transcribed text, following the same T2T algorithm described above.<br>

## Text-to-Voice (T2V)
This process reads incoming messages aloud, also using the Web Speech API (SpeechSynthesis).<br>

1. Trigger:<br>
- The T2V process is triggered within the ```channel.onmessage``` handler when a new_message is received from the other user.<br>

2. Condition Check:<br>
- The code checks if the receiving user's own microphone is currently active (i.e., if ```isRecognizing``` is true). The voice playback only occurs if this condition is met.<br>

3. Speech Synthesis (```speak function```):<br>
- If the condition is met, the ```speak(text)``` function is called with the incoming message text.<br>
- This function uses the ```window.speechSynthesis``` interface.<br>
- It creates a new ```SpeechSynthesisUtterance``` object. This object contains the text to be spoken and configuration details, such as the language (```lang: 'ja-JP'```).<br>
- The ```synth.speak(utterance)``` method is called, instructing the browser to read the text aloud using its built-in text-to-speech engine.<br>


# How to use
To run this chat application, you will need to use a simple local web server. This is necessary because modern web browsers have security policies that prevent direct communication between tabs when files are opened directly from your computer (i.e., using a file:/// URL).
You will need Python 3 installed on your system. Most macOS and Linux systems have it pre-installed.
<br>Follow these steps to get the application running: <br> 
1. Open your Terminal.<br>
2. On macOS, you can find it via Launchpad or Spotlight Search.
   On Windows, you can use Command Prompt or PowerShell.
   Navigate to the project directory. Use the cd (change directory) command to go to the folder where your project files are located.<br>
3. Start the local web server. Run the following command in your terminal. This will start a web server on port 8000.
```bash:title
cd /<path>/chatapp
```
4. You should see a message like Serving HTTP on :: port 8000 (http://0.0.0.0:8000/) .... Keep this terminal window open while you are using the application.
```bash
python3 -m http.server
```
5. Open the chat in your web browser.<br>
For User 1: Open a new browser tab and go to the following address: http://localhost:8000/user1.html<br>
For User 2: Open another browser tab and go to this address: http://localhost:8000/user2.html


# User Interface
The system is ultimately intended for smartphones. However, as I am not yet familiar with native smartphone app development, the initial prototype will be built with **HTML** and **JavaScript**. Subsequently, I plan to develop a native application for smartphones.

# Future
I have the following two plans for the future:<br>
1. **Develop** a native smartphone application to provide a better user experience.
2. **Implement** a full voice-to-voice (call) feature, including the ability to seamlessly switch between the call and the hybrid text/voice modes during a conversation.



